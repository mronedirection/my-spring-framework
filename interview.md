# 项目相关问题

**简单介绍一下这个项目？**

对于Java开发程序员来说，Spring全家桶是非常重要的，而作为其中基石的Spring框架更是重中之重，因此本项目通过对Spring源码的学习与理解，完成了Spring框架的**IOC、AOP和MVC功能模块**的开发、**Bean的生命周期**等功能的开发。通过从 0 搭建一个较为完备的 Web 框架来提升框架设计能力，了解 Spring 框架的设计思路。



**项目亮点：**

1.自研IOC容器的实现，包括解析配置、依赖注入，控制反转功能；

2.自研AOP的实现，使用Cglib动态代理实现自研AOP，并引入AspectJ框架，使用pointcut灵活织入切面逻辑；

3.自研MVC的实现：创建中央调度器，对HTTP连接重构，创建请求处理以及结果渲染的相关矩阵，以责任链的模式执行请求，并对处理结果进行渲染；



# 一、IOC相关问题



## 框架具备的基本功能

- 解析配置（XML、注解等）
- 定义和注册对象
- 注入对象
- 提供通用的工具类

## IoC容器的实现

创建注解-->提取标记对象-->实现容器-->依赖注入



## **如何实现自研框架的IOC?**

具体实现流程为：

1. 创建注解标记需要被容器管理的类：

   创建与IOC相关的注解Component、Controller、Service以及Repository，用于标记需要被BeanContainer管理的类； 

2. 创建管理Bean的容器类BeanContainer：

   提取指定范围内的所有被注解标记的类并加载进容器中，可用ConcurrentHashMap进行保存，键代表Class对象，值代表对应的实例； 

​       BeanContainer容器的操作方式，主要涉及到容器的增删改查操作；

3. 依赖注入：

​	   由于实例里面某些必须的成员变量还没有被创建出来，因此还需进行依赖注入； 

​		定义依赖注入相关的注解标签Autowired，被此标签标记的成员变量在Spring初始化时，需要被容器创建对应		的实例，并将其注入到成员变量里；

依赖注入的具体实现逻辑为：

- 定义相关的注解标签@Autowired
- 从BeanContainer中获取被@Autowired注解标记的成员变量的实例，并通过反射将其注入到成员变量里

至此，就实现了IOC容器的创建以及依赖注入；



## 为什么要使用IOC？/谈谈你对IOC的理解？

**IoC（Inversion of Control:控制反转）** 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spring 特有，在其他语言中也有应用。

**什么是IOC：**

控制反转中的控制指的是对象创建（实例化、管理）的权力，反转指的是将控制权交给外部环境（Spring 框架、IoC 容器）；

将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。

在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。

Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。

1. 控制反转 IoC (Inversion of Controller)
   - 依托一个类似工厂的 **IoC 容器**
   - 将对象的**创建**、依赖关系的**管理**以及**生命周期**交由IoC容器管理
   - 降低系统在实现上的**复杂性和耦合度**,易于扩展,满足**开闭原则**（软件中的对象（类、模块、方法等），对于**扩展是开放的**，对于**修改是封闭的**）

2. IoC容器的优势
   - **避免在各处使用new来创建类** ,并且可以做到统一维护
   - 创建实例的时候不需要 了解其中的细节
   - 反射+工厂模式的合体,满足开闭原则

3. 依赖注入 
   - 构造方法实现注入 
   - setter实现注入 
   - 接口实现注入
   - 注解实现注入



## 依赖注入是如何实现的？

之所以需要依赖注入，是因为在拿到Bean实例之后，Bean中的属性由于没有设置，因此还是null，因此，需要使用依赖注入来创建必要的成员变量，并将其注入Bean实例中，项目中具体实现思路是：

**实现思路**

   - 定义相关的注解标签

   - 实现创建被注解标记的成员变量的实例，并将其注入到成员变量里

     - 遍历 Bean 容器中所有的 Class 对象
     - 遍历 Class 对象的所有成员变量
     - 找出被 Autowired 标记的成员变量
     - 获取这些成员变量的类型
     - 获取这些成员变量的类型在容器里对应的实例
     - 通过反射将对应的成员变量实例注入到成员变量所在类的实例里



## 什么是循环依赖？

A对象在创建的过程中，需要依赖注入B对象，但是B对象还未被创建，于是需要先去创建B对象，但是在创建B对象的过程中又需要注入A对象，AB互相等待对方先创建完成，这样就构成了一个死循环，AB相互依赖的关系被称为**循环依赖**。

## 如何解决循环依赖问题？

***\*Spring使用三级缓存来解决循环依赖的问题\****

singletonObjects （一级缓存）：缓存创建完成的单例Bean

earlySingletonObjects（二级缓存）：缓存不完整的Bean实例

singletonFactories（三级缓存）： 缓存创建Bean的原始工厂

三级缓存解决A和B循环依赖的问题：

1. 实例化 A，此时 A 还未完成依赖注入，只是一个半成品，为 A 创建一个 Bean工厂，将其放入三级缓存中
2. 发现 A 需要注入 B 对象，但是一级、二级、三级缓存均未发现对象 B
3. 实例化 B，此时 B 也只是一个半成品，为 B 创建一个 Bean工厂，并放入到 三级缓存中
4. 由于B 需要注入 A 对象，因此可以从三级缓存中得到对象 A，并将对象 A 放入二级缓存中，同时删除三级缓存中的对象 A
5. 对象 B 完成属性填充，执行初始化方法，并放入到一级缓存中，同时删除三级缓存中的对象 B
6. 对象 A 从一级缓存中得到对象B，完成属性填充，并放入到一级缓存中，同时删除二级缓存中的对象 A

## 为什么需要三级缓存？

如果仅仅是解决循环依赖问题，使用二级缓存就可以了，但是如果对象实现了AOP，那么注入到其他bean的时候，并不是最终的代理对象，而是原始的，这样就会产生错误。这时就需要通过三级缓存的ObjectFactory才能提前产生最终的需要代理的对象。

## **spring能解决那些循环依赖、不能解决那些循环依赖，为什么？**

***\*Spring能够解决的循环依赖情况\****：

1. 通过setter方法进行依赖注入且是在单例模式下产生的循环依赖问题：

   可以通过三级缓存解决；

**Spring不能解决的循环依赖情况：**

1. 通过构造方法进行依赖注入时产生的循环依赖问题：

   在new对象的时候就被堵塞住了，无法创建实例；

   解决办法：可以在A或者B的构造函数的形参上加个@Lazy注解实现延迟加载。@Lazy实现原理是，当实例化对象时，如果发现参数或者属性有@Lazy注解修饰，那么就不直接创建所依赖的对象了，而是使用动态代理创建一个代理类。

2. 通过setter方法进行依赖注入且是在多例（原型）模式下产生的循环依赖问题：

   每一次getBean()时，都会产生一个新的Bean，如此反复下去就会有无穷无尽的Bean产生了，最终导致StackOverflowError；
   



# 二、AOP相关问题

## 什么是AOP，和OOP的区别是什么？

容器是 OOP 的高级工具，以低耦合低侵入的方式打通从上到下的开发通道：

- 按部就班填充代码逻辑实现业务功能，每层逻辑都可无缝替换
- **OOP将业务程序分解成各个层次的对象，通过对象联动完成业务**
- 无法很好地处理分散在各业务里的**通用系统需求**

系统需求是指程序员才去关心的需求：

- 添加日志信息:为每个方法添加统计时间
- 添加系统权限校验∶针对某些方法进行限制
- OOP下必须得为每个方法都添加通用的逻辑工作，增加维护成本

关注点分离原则：不同的问题交给不同的部分去解决，每部分专注解决自己的问题

### 为什么要使用AOP：

AOP 是一种编程思想，是面向对象编程（OOP）的一种补充，主要应用于处理一些**具有横切性质的系统级服务**；

AOP可以**拦截指定的方法并对方法增强**，而且无需侵入到业务代码中，主要作用是分**离功能性需求和非功能性需求**，使开发人员可以集中处理某一个关注点或者横切逻辑，**减少对业务代码的侵入**，增强代码的可读性和可维护性。

**简单的说**，AOP 的作用就是保证开发者在不修改源代码的前提下，为系统中的业务组件添加某种通用功能。

应用场景：日志记录、事务管理、权限验证、性能监测



## AOP的几个关键概念？

- 切面 Aspect :把通知应用到切入点的过程，将横切关注点逻辑进行模块化封装的实体对象
- 通知 Advice :在选取出来的JoinPoint上**要执行的操作、逻辑**，是待织入的方法，还定义了织入逻辑的时机，好比是 Class 里面的方法
- 连接点 Joinpoint :通过pointcut选取出来的集合中的**具体的一个执行点**，我们就叫JoinPoint，是类里面可以被增强的方法，允许使用 Advice 的地方
- 切入点 pointcut :是实际被增强的方法，**织入切面逻辑时候的切入点**，是一个基于正则表达式的表达式，通常一个pointcut，会选取程序中的某些我们感兴趣的执行点，或者程序执行点的集合，我们可以定义一系列规则对Joinpoint进行筛选
- 目标对象Target :是指符合Pointcut条件，要被织入横切逻辑的对象
- Weaving：是指把切面应用到目标对象来创建新的 advised 对象的过程。
- SpringAOP 默认只支持方法级别的 Joinpoint



### Advice的种类：

- BeforeAdvice :在JoinPoint前被执行的Advice
- AfterAdvice :好比try..catch..finaly里面的finaly
- AfterReturningAdvice :在Joinpoint执行流程正常返回后被执行
- AfterThrowingAdvice : Joinpoint执行过程中抛出异常才会触发
- AroundAdvice :在Joinpoint前和后都执行，最常用的Advice



### Aspect的执行顺序

单个 Aspect 的执行顺序

<img src="F:/code/IdeaProjects/spring/simpleframework/img/image-20210310185418129.png" alt="image-20210310185418129" style="zoom: 80%;" />

多个 Aspect 的执行顺序

<img src="F:/code/IdeaProjects/spring/simpleframework/img/image-20210310185454340.png" alt="image-20210310185454340" style="zoom: 80%;" />

1. 按照order的顺序**升序执行**完所有Aspect的**before方法**
2. 执行被代理类的方法
3. 如果被代理方法正常返回，则按照order的顺序**降序执行**完所有Aspect的**afterReturning方法**
4. 如果被代理方法抛出异常，则按照order的顺序**降序执行**完所有Aspect的**afterThrowing方法**

## **如何实现自研框架的AOP?**

项目中使用Cglib动态代理实现SpringAOP，优点是**不要求被代理类实现接口**，能实现代理类的无侵入

具体实现流程为：

1. **创建注解**标记需要被容器管理的切面类：

   创建与AOP相关的注解Aspect和Order，用于**标记切面类**，以及切面类的**执行顺序**；

2. 定义供外部切面类使用的**横切逻辑骨架**：

   骨架中**包含before, afterReturning以及afterThrowing等待实现的方法**；

3. 实现横切逻辑以及被代理对象方法的**定序执行**：

   由于使用Cglib动态代理生成动态代理对象，因此需要**创建 MethodInterceptor 的实现类** AspectListExecutor，在该类中**按照 Order 对 Aspect 标记的切面类进行排序**，实现横切逻辑以及被代理对象方法的定序执行；

4. 织入横切逻辑**生成动态代理对象**：

   将横切逻辑织入到被代理对象以生成动态代理对象，替**换容器中的原始对象**；

5. **引入AspectJ的切面表达式**和相关的定位解析机制：

   在织入切面逻辑时，为了**实现更加细粒度的控制**，引入AspectJ框架中的pointcut表达式让切面逻辑的织入更加灵活；

使用Cglib动态代理实现的AOP1.0的不足地方：

- Aspect 标记的横切类只支持对某个标签标记的类进行横切逻辑的织入
- 需要披上 AspectJ 的外衣

**引入AspectJ的AOP 2.0：**

- 引入 AspectJ的切面表达式和相关的定位解析机制，使用pointcut 可以让切面逻辑的织入更加灵活；



## JDK动态代理和Cglib(Code Generation Library) 动态代理的区别？

JDK动态代理机制是通过**让动态代理类来实现和被代理类同样的接口**，从而在运行中去替代被代理类来进行工作；

cglib类似子类继承，可以代理没实现接口的类，其实就是**在子类中调用父类方法**；

- 实现机制不同：
  - JDK动态代理基于**反射机制**实现，要求被代理类必须实现接口
  - Cglib基于 **ASM 机制**实现，通过生成被代理类的子类作为代理类，被代理类不需要实现接口

- 两者各有优势：
  - JDK动态代理的优势在于**JDK原生**，不需要额外引入依赖，在JVM 中**运行较为可靠**，平滑支持JDK版本的升级，而Cglib**可能需要更新**，才能在新版JDK中使用 
  - Cglib动态代理的优势在于**被代理类无需实现接口，能实现代理类的无侵入**

SpringAOP的底层机制是**Cglib和JDK动态代理共存**，如果Bean 实现了接口则用 JDK，否则使用 Cglib；



## Spring AOP 和 AspectJ的区别？

Spring框架中可以使用Spring自带的AOP或者使用Aspectj实现切面，AspectJ，本身是单独的框架，不属于Spring组成部分，独立于AOP框架，一般把AspectJ和Spring框架一起使用，进行AOP操作，因为AspectJ引入了Pointcut表达式，可以实现对某个类的某个方法进行增强，使用起来更加灵活简便；

**能力和目标不同：**

- Spring AOP是基于Spring IoC实现的，对于**非Spring容器管理的对象，则无法使用**；
- AspectJ是一个独立的框架，旨在**提供完整的AOP方案，可以应用于所有域对象**；

**织入方式不同：**

- AspectJ是在**运行前织入的，支持三种不同的织入方式**，包括编译时织入、编译后织入和加载时织入；
- Spring AOP则使用JDK 动态代理或 CGLIB 动态代理在**运行时织入**；

**支持的连接点不同：**

- Spring AOP**仅支持方法执行切入点**，此外**无法支持final和静态的方法**，因为这些方法无法通过动态代理来改变；
- AspectJ**支持所有切入点**，比如方法，属性，构造器等；

**性能不同：**

- Spring AOP是使用代理模式在**运行时**才创建对应的代理类，而AspectJ 是在应**用程序执行之前将这些切面织入到主代码中,** 因此没有额外的**运行时开销**，效率要比Spring AOP高；



# 三、MVC相关问题

## **如何实现自研框架的MVC?**

具体实现流程为：

1. HTTP连接重构：

   **创建**实现HttpServlet的**中央调度器**DispatcherServlet**拦截所有请求**，

   在init方法中对容器进行初始化，以及初始化请求处理器责任链，**以责任链的模式执行注册的请求处理器**；

   在service方法中顺序执行请求处理器责任链中的请求，并对处理结果进行渲染；

2. 实现请求处理器矩阵：

   请求处理器主要包括PreRequestProcessor进行**请求预处理**；

   StaticResourceRequestProcessor进行**静态资源请求处理**；

   JspRequestProcessor对访问**jsp资源**的**请求**进行**处理**；

   以及最关键的ControllerRequestProcessor，负责**针对特定请求**，解析请求中的参数，将其**传递给匹配的Controller方法进行处理**；

3. 实现结果渲染矩阵：

   对结果进行渲染相关的类ResultRender，主要包括

   **内部异常渲染器**InternalErrorResultRender，

   **资源找不到**时使用的**渲染器**ResourceNotFoundResultRender，

   **Json渲染器**JsonResultRender，

   以及**页面渲染器**ViewResultRender，将请求处理器处理完后的结果显示到指定的视图上；

执行原理：

1. 当发起请求时首先被中央调度器DispatcherServlet**拦截请求**
2. 中央调度器找到请求对应的**实际处理器**
3. 实际处理器根据业务逻辑**处理请求**，并将处理结果**响应给中央调度器**
4. 中央调度器将处理结果**传入视图**中进行渲染
5. 最后，中央调度器将渲染后的视图**返回响应**

## 什么是MVC架构？与Spring MVC的关系？

经典MVC模式中：

**M即model模型是指业务模型，模型指企业数据（即实体类）和业务规则**；

**V即View视图**是指用户看到并与之交互的界面；

**C即controller控制器**是指控制器接受用户的输入并调用模型和视图去完成用户的需求，控制器本身不输出任何东西和做任何处理。它只是接收请求并决定调用哪个模型构件去处理请求，然后再确定用哪个视图来显示返回的数据。

springMVC框架是基于Java的**实现了MVC框架模式**的请求驱动类型的轻量级框架。围绕DispatcherServlet设计，将请求分发到不同的处理器，具体原理为：

当发起请求时被前端控制器DispatcherServlet**拦截请求**，

前端控制器找到请求对应的**实际控制器**，

实际控制器根据业务逻辑**处理请求**，并将处理结果**响应给中央控制器**，

中央控制器将处理结果**传入视图**View中进行渲染，

中央控制器将渲染后的视图**返回响应**。

## 为什么要使用MVC架构？

**使用MVC的目的是将M和V的实现代码分离**，从而使同一个程序可以使用不同的表现形式，实现model层代码的复用，同时方便扩展和维护。比如一批统计数据可以分别用柱状图或者饼状图来表示。

# 四、Spring相关问题

## **什么是Spring？**

Spring 是一款开源的轻量级 Java 开发框架，旨在提高开发人员的开发效率以及系统的可维护性。

我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发，比如说 Spring 支持 IoC（Inversion of Control:控制反转） 和 AOP(Aspect-Oriented Programming:面向切面编程)、可以很方便地对数据库进行访问、可以很方便地集成第三方组件（电子邮件，任务，调度，缓存等等）、对单元测试支持比较好、支持 RESTful Java 应用程序的开发。

Spring 最核心的思想就是不重新造轮子，开箱即用，提高开发效率。



##  **Spring 核心模块有哪些？**

#### Core Container

Spring 框架的核心模块，也可以说是基础模块，主要提供 IoC 依赖注入功能的支持。Spring 其他所有的功能基本都需要依赖于该模块。

- **spring-core**：Spring 框架基本的核心工具类。
- **spring-beans**：提供对 bean 的创建、配置和管理等功能的支持。
- **spring-context**：提供对国际化、事件传播、资源加载等功能的支持。
- **spring-expression**：提供对表达式语言（Spring Expression Language） SpEL 的支持，只依赖于 core 模块，不依赖于其他模块，可以单独使用。

#### AOP

提供了面向切面的编程实现；

- **spring-aspects**：该模块为与 AspectJ 的集成提供支持。
- **spring-aop**：提供了面向切面的编程实现。
- **spring-instrument**：提供了为 JVM 添加代理（agent）的功能。 具体来讲，它为 Tomcat 提供了一个织入代理，能够为 Tomcat 传递类文 件，就像这些文件是被类加载器加载的一样。没有理解也没关系，这个模块的使用场景非常有限。

#### Data Access/Integration

- **spring-jdbc**：提供了对数据库访问的抽象 JDBC。不同的数据库都有自己独立的 API 用于操作数据库，而 Java 程序只需要和 JDBC API 交互，这样就屏蔽了数据库的影响。
- **spring-tx**：提供对事务的支持。
- **spring-orm**：提供对 Hibernate、JPA、iBatis 等 ORM 框架的支持。
- **spring-oxm**：提供一个抽象层支撑 OXM(Object-to-XML-Mapping)，例如：JAXB、Castor、XMLBeans、JiBX 和 XStream 等。
- **spring-jms** : 消息服务。自 Spring Framework 4.1 以后，它还提供了对 spring-messaging 模块的继承。

#### Spring Web

- **spring-web**：对 Web 功能的实现提供一些最基础的支持。
- **spring-webmvc**：提供对 Spring MVC 的实现。
- **spring-websocket**：提供了对 WebSocket 的支持，WebSocket 可以让客户端和服务端进行双向通信。
- **spring-webflux**：提供对 WebFlux 的支持。WebFlux 是 Spring Framework 5.0 中引入的新的响应式框架。与 Spring MVC 不同，它不需要 Servlet API，是完全异步。

#### Messaging

**spring-messaging** 是从 Spring4.0 开始新加入的一个模块，主要职责是为 Spring 框架集成一些基础的报文传送应用。

#### Spring Test

Spring 团队提倡测试驱动开发（TDD）。有了控制反转 (IoC)的帮助，单元测试和集成测试变得更简单。

Spring 的测试模块对 JUnit（单元测试框架）、TestNG（类似 JUnit）、Mockito（主要用来 Mock 对象）、PowerMock（解决 Mockito 的问题比如无法模拟 final, static， private 方法）等等常用的测试框架支持的都比较好。

1. spring-core

   包含框架基本的核心工具类，其他组件都要使用到这个包里的类；

2. spring-beans 

   Spring主要面向Bean编程（BOP）；

   包含Bean的定义、解析、创建；

3. spring-context 

   为Spring提供运行时环境，保存对象的状态；

   扩展了BeanFactory；

4. spring-aop 

   提供了面向切面的编程实现；



##  **Spring,Spring MVC,Spring Boot 之间什么关系?**

Spring 包含了多个功能模块（上面刚刚提到过），其中最重要的是 Spring-Core（主要提供 IoC 依赖注入功能的支持） 模块， Spring 中的其他模块（比如 Spring MVC）的功能实现基本都需要依赖于该模块。

Spring MVC 是 Spring 中的一个很重要的模块，主要赋予 Spring 快速构建 MVC 架构的 Web 程序的能力。MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。

使用 Spring 进行开发各种配置过于麻烦比如开启某些 Spring 特性时，需要用 XML 或 Java 进行显式配置。于是，诞生了Spring Boot ！

Spring Boot 只是简化了配置，如果你需要构建 MVC 架构的 Web 程序，你还是需要使用 Spring MVC 作为 MVC 框架，只是说 Spring Boot 帮你简化了 Spring MVC 的很多配置，真正做到开箱即用！



**什么是 Spring Bean？**

Bean 代指的就是那些被 IoC 容器所管理的对象，将一个类声明为Bean的注解可以使用：

`@Component`：通用的注解，可标注任意类为 `Spring` 组件。如果一个 Bean 不知道属于哪个层，可以使用`@Component` 注解标注。

`@Repository` : 对应持久层即 Dao 层，主要用于数据库相关操作。

`@Service` : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。

`@Controller` : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 `Service` 层返回数据给前端页面。



**@Component 和 @Bean 的区别是什么？**

`@Component` 注解作用于类，而`@Bean`注解作用于方法。

`@Component`通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 `@ComponentScan` 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。`@Bean` 注解通常是我们在标有该注解的方法中定义产生这个 bean,`@Bean`告诉了 Spring 这是某个类的实例。

`@Bean` 注解比 `@Component` 注解的自定义性更强，而且很多地方我们只能通过 `@Bean` 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 `Spring`容器时，则只能通过 `@Bean`来实现。



**注入 Bean 的注解有哪些？**

Spring 内置的 `@Autowired` 以及 JDK 内置的 `@Resource` 和 `@Inject` 都可以用于注入 Bean。

`@Autowired` 和`@Resource`使用的比较多一些。

**@Autowired 和 @Resource 的区别：**

`@Autowired` 是 Spring 提供的注解，`@Resource` 是 JDK 提供的注解。

`Autowired` 默认的注入方式为`byType`（根据类型进行匹配），`@Resource`默认注入方式为 `byName`（根据名称进行匹配）。

当一个接口存在多个实现类的情况下，`@Autowired` 和`@Resource`都需要通过名称才能正确匹配到对应的 Bean。`Autowired` 可以通过 `@Qualifier` 注解来显式指定名称，`@Resource`可以通过 `name` 属性来显式指定名称。

`@Autowired` 支持在构造函数、方法、字段和参数上使用。`@Resource` 主要用于字段和方法上的注入，不支持在构造函数或参数上使用。







## Spring中，有几种织入切面逻辑的方式？

# 五、项目中的其它问题

## 用到的设计模式？

### **门面模式(Facade)**

提供一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用。

门面（Facade）模式包含以下主要角色：

- 外观（Facade）角色：为多个子系统对外提供一个共同的接口。
- 子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。

### 工厂模式

工厂模式将创建对象的**具体过程屏蔽隔离**起来，从而达到更高的灵活性，工厂模式可以分为三类：

**简单工厂**

简单工厂模式包含以下几个主要组成部分：

1. 产品接口（Product Interface）：定义了工厂所创建的对象的共同接口。该接口可以是一个抽象类或者接口，定义了产品对象的行为。
2. 具体产品（Concrete Product）：实现了产品接口的具体对象，是工厂所创建的对象的具体类型。
3. 简单工厂（Simple Factory）：负责创建产品对象的工厂类。它根据客户端的请求，决定实例化哪个具体产品对象，并将其返回给客户端。

简单工厂模式的工作流程如下：

1. 客户端通过调用工厂类的方法来请求一个产品对象。
2. 工厂类根据客户端的请求，决定实例化哪个具体产品对象。
3. 工厂类实例化具体产品对象，并将其返回给客户端。
4. 客户端通过产品接口操作具体产品对象。

**工厂方法**

工厂方法模式将工厂抽象化，并定义一个创建对象的接口。每增加新产品，只需增加该产品以及对应的具体实现工厂类，由具体工厂类决定要实例化的产品是哪个，将对象的创建与实例化延迟到子类，这样工厂的设计就符合“开闭原则”了，扩展时不必去修改原来的代码。

工厂方法模式包含以下几个主要组成部分：

1. 抽象产品（Abstract Product）：具体产品继承的父类或实现的接口，在 Java 中一般由抽象类或者接口来实现。
2. 具体产品（Concrete Product）：实现了产品接口的具体对象，是工厂所创建的对象的具体类型。
3. 具体工厂（Factory）：被应用程序调用以创建具体产品的对象，含有和具体业务逻辑有关的代码。
4. 抽象工厂（AbstractFactory）：工厂方法模式的核心，是具体工厂角色必须实现的接口或者必须继承的父类，在 Java 中它由抽象类或者接口来实现。

**抽象工厂**

抽象工厂模式主要**用于创建相关对象的家族**。当一个产品族中需要被设计在一起工作时，通过抽象工厂模式，能够保证客户端始终只使用同一个产品族中的对象。

抽象工厂模式包含以下几个主要组成部分：

1. 抽象产品（Abstract Product）：具体产品继承的父类或实现的接口，在 Java 中一般由抽象类或者接口来实现。
2. 具体产品（Concrete Product）：实现了产品接口的具体对象，是工厂所创建的对象的具体类型。
3. 具体工厂（Factory）：用于生产不同产品族，要创建一个产品，用户只需使用其中一个工厂进行获取，完全不需要实例化任何产品对象。
4. 抽象工厂（AbstractFactory）：定义了一个接口，这个接口包含了一组方法用来生产产品，所有的具体工厂都必须实现此接口。

### 代理模式

代理模式最主要的就是有一个公共接口（ToCPayment），一个具体的被代理类（ToCPaymentImpl）以及一个代理类（AlipayToC），代理类持有被代理类的实例，代为执行被代理类实例的方法。用于在真实的实现前后添加一部分通用逻辑。

应用：SpringAOP使用的就是代理模式

#### 静态代理模式：

**在编译时就已经将接口、被代理类、代理类等确定下来**。在程序运行之前，代理类的.class文件就已经生成。

静态代理的局限性：针对不同接口中同样的连接点，植入相同的逻辑，需要单独实现不同的代理类，维护成本会呈指数级增长；

#### 动态代理模式：

动态代理并没有实际的 class 文件，而是在**程序运行时生成类的字节码文件**并加载到 JVM 中

##### JDK动态代理：

JDK动态代理机制是通过**让动态代理类来实现和被代理类同样的接口，从而在运行中去替代被代理类来进行工作**；要求**【被代理的类】必须实现接口**，但是并不要求代理类【代理对象】去实现接口，所以可以复用代理对象的逻辑；

##### CGLIB动态代理：

Cglib基于 ASM 机制实现，**通过生成被代理类的子类作为代理类**，**被代理类不需要实现接口**；

SpringAOP的底层机制是Cglib和JDK动态代理共存，如果Bean 实现了接口则用 JDK，否则使用 Cglib；



### 单例模式

单例模式可以使用四种方式实现，懒汉式，饿汉式，内部类，内部枚举类，特别是使用内部枚举类的方式构造单例，可以保证即使使用反射中的爆破，也可以保证单例，因此在项目中，IOC容器BeanContainer的单例实现就是使用的内部枚举类；



## 用到的比较难的点？

设计模式的理解，反射的灵活使用，自定义注解的实现，枚举类的使用等；

使用内部枚举类构造IOC容器BeanContainer的单例实现；

使用ConcurrentHashMap来存储Bean，**支持高并发更新与查询**，保证高并发情况下的数据一致性；



## ConcurrentHashMap与HashMap和HashTable的区别？

**基本概念不同：**

ConcurrentHashMap是一个**支持高并发更新与查询**的哈希表，**是HashTable的替代品**；

HashMap是基于哈希表的**Map接口的实现**，**允许使用null值和null键**，是线程不安全的；

HashTable和HashMap的实现原理几乎一样，但是不允许key和value为null，是线程安全的；

**底层数据结构不同**：

**HashMap**的底层数据结构主要是：**数组+链表+红黑树**，确切地说是以链表为元素的数组；

**ConcurrentHashMap**的底层数据结构是：**Segments数组**+**HashEntry数组**+**链表**；

**HashTable**的底层数据结构是：**数组+链表**；

**实现线程安全的方式不同**：

ConcurrentHashMap采用**分段锁实现线程安全**，容器中有多把锁，每一把锁锁一段数据，这样在多线程访问不同段的数据时，就不会存在锁竞争了，这样便可以有效地提高并发效率；

Hashtable采用synchronized来实现线程安全，在方法上加synchronized同步锁。



## Java中如何实现自定义注解？

1. 注解的功能
   - 作为特定的标记，用于告诉编译器一些信息
   - 编译时动态处理，如动态生成代码
   - 运行时动态处理，作为额外信息的媒体，如获取注解信息
2. 注解的分类
   - 标准注解：@Override、@Deprecated、@SupressWarnings
   - 元注解(修饰注解的注解，通常用在注解的定义之上)：@Retention、@Target、@Inherited、@Documented
     @Target：定义注解的作用目标
      @Retention：定义注解的生命周期，用于决定被该元注解修饰的注解是否显示在编译的文件中
      @Inherited：是否允许子类继承该注解
      @Documented：注解是否应当被包含在 JavaDoc 文档中
   - 自定义注解(使用元注解实现)

3. 自定义注解
   - 自定义注解格式

```java
public @interface 注解名{
    修饰符 返回值 属性名() 默认值;
    修饰符 返回值 属性名() 默认值;
    ...
}
```

   - 注解属性支持的类型

     - 所有的基本数据类型
     - Enum类型

       - String类型
       - Annotation类型
       - Class 类型
       - 以上所有类型的数组

5. **注解的工作原理**

- 通过**键值对**的形式为注解属性**赋值**
- 编译器检查注解的**使用范围**，将注解信息**写入元素属性表**
- 运行时 JVM 将 RUNTIME 的所有注解属性取出并最终存入 map 里（单个Class文件内所有的RUNTIME的注解而非整个项目的RUNTIME注解）
- 创建AnnotationInvacationHandler实例并传入前面的map
- JVM使用JDK动态代理为注解生成动态代理类，并初始化处理器
- 调用invoke方法，通过传入方法名返回注解对应的属性值
