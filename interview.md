# 一、IOC相关问题

## **如何实现自研框架的IOC?**

具体实现流程为：

1. 创建注解：

   创建与IOC相关的注解Component、Controller、Service以及Repository，用于标记需要被BeanContainer管理的类； 

2. 创建BeanContainer，提取指定范围内的所有被注解标记的类并加载进容器中，可用ConcurrentHashMap进行保存，键代表大Class对象，值代表对应的实例； 

3.  BeanContainer容器的操作方式，主要涉及到容器的增删改查操作；

4.  由于实例里面某些必须的成员变量还没有被创建出来，因此还需进行依赖注入； 

5. 定义依赖注入相关的注解标签Autowired，被此标签标记的成员变量在Spring初始化时，需要被容器创建对应的实例，并将其注入到成员变量里；

具体实现逻辑为：

- 遍历 Bean 容器中所有的     Class 对象
- 遍历 Class 对象的所有成员变量
- 找出被 Autowired 标记的成员变量
- 获取这些成员变量的类型
- 获取这些成员变量的类型在容器里对应的实例
- 通过反射将对应的成员变量实例注入到成员变量所在类的实例里

至此，就实现了IOC容器的创建以及依赖注入；

## 为什么要使用IOC？

## 如何解决循环依赖问题？

# 二、AOP相关问题

## **如何实现自研框架的AOP?**

具体实现流程为：

1. 定义与横切逻辑相关的注解Aspect和Order，用于标记切面类，以及切面类的执行顺序；

2. 定义供外部使用的横切逻辑骨架，骨架中包含before, afterReturning以及afterThrowing等未实现的方法（此处用到了代理模式）；

3. 创建 MethodInterceptor 的实现类 AspectListExecutor，按照 Order 对 Aspect 标记的切面类进行排序，并实现横切逻辑intercept以及被代理对象方法的定序执行；

4. 织入横切逻辑生成动态代理对象的实现类，替换BeanContainer中对应类的实例；

使用Cglib动态代理实现的AOP1.0的不足地方：

- Aspect 标记的横切类只支持对某个标签标记的类进行横切逻辑的织入
- 需要披上 AspectJ 的外衣

**引入AspectJ的AOP 2.0：**

- 引入 AspectJ的切面表达式和相关的定位解析机制，使用pointcut 可以让切面逻辑的织入更加灵活；

## 为什么要使用AOP？

## JDK动态代理和Cglib(Code Generation Library) 动态代理的区别？

jdk只能代理接口或者接口的实现类，然后去调接口的实现方法；

cglib类似子类继承，可以代理没实现接口的类，其实就是在子类中调用父类方法；

JDK 动态代理：

- 并没有实际的 class 文件，而是在程序运行时生成类的字节码文件并加载到 JVM 中
- 要求被代理的类必须实现接口
- 并不要求代理对象去实现接口，所以可以复用代理对象的逻辑

Cglib(Code Generation Library) 动态代理：

- 不要求被代理类实现接口
- 内部主要封装了ASM Java字节码操控框架
- 动态生成子类以覆盖非 final 的方法，绑定钩子回调自定义拦截器

## pointcut是怎么用的，为什么使用pointcut可以让切面逻辑的织入更加灵活？

## 什么是AOP，和OOP的区别是什么？

# 三、MVC相关问题

## **如何实现自研框架的MVC?**

具体实现流程为：

1. 创建实现HttpServlet的中央调度器DispatcherServlet拦截所有请求，在init方法中对容器进行初始化，以及初始化请求处理器责任链，以责任链的模式执行注册的请求处理器；在service方法中顺序执行请求处理器责任链中的请求，并对处理结果进行渲染；

2. 请求处理器主要包括PreRequestProcessor进行请求预处理，StaticResourceRequestProcessor进行静态资源请求处理，JspRequestProcessor对访问jsp资源的请求进行处理，以及最关键的ControllerRequestProcessor，负责针对特定请求，解析请求里的参数及对应的值，并赋值给Controller方法的参数，选择匹配的Controller方法进行处理，同时选择合适的Render，为后续请求处理结果的渲染做准备；

3. 对结果进行渲染相关的类ResultRender，主要包括内部异常渲染器InternalErrorResultRender，资源找不到时使用的渲染器ResourceNotFoundResultRender，Json渲染器JsonResultRender，以及页面渲染器ViewResultRender，将请求处理器处理完后的结果显示到指定的视图上；

## 为什么要使用MVC架构？

# 四、Spring相关问题

## **Spring核心模块有哪些？**

1. spring-core

   包含框架基本的核心工具类，其他组件都要使用到这个包里的类；

   定义并提供资源的访问方式；

2. spring-beans 

   Spring主要面向Bean编程（BOP）；

   包含Bean的定义、解析、创建；

3. spring-context 

   为Spring提供运行时环境，保存对象的状态；

   扩展了BeanFactory；

4. spring-aop 

   最小化的动态代理实现；

   JDK动态代理；

   Cglib；

   只能使用运行时织入，仅支持方法级编织，仅支持方法执行切入点；

## Spring中，有几种织入切面逻辑的方式？

# 五、项目中的其它问题

## 用到的设计模式？

### **门面/外观模式(Facade)**

提供一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用。

外观（Facade）模式包含以下主要角色：

- 外观（Facade）角色：为多个子系统对外提供一个共同的接口。
- 子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。

### 工厂模式

工厂模式将创建对象的**具体过程屏蔽隔离**起来，从而达到更高的灵活性，工厂模式可以分为三类：

**简单工厂**

简单工厂模式包含以下几个主要组成部分：

1. 产品接口（Product Interface）：定义了工厂所创建的对象的共同接口。该接口可以是一个抽象类或者接口，定义了产品对象的行为。
2. 具体产品（Concrete Product）：实现了产品接口的具体对象，是工厂所创建的对象的具体类型。
3. 简单工厂（Simple Factory）：负责创建产品对象的工厂类。它根据客户端的请求，决定实例化哪个具体产品对象，并将其返回给客户端。

简单工厂模式的工作流程如下：

1. 客户端通过调用工厂类的方法来请求一个产品对象。
2. 工厂类根据客户端的请求，决定实例化哪个具体产品对象。
3. 工厂类实例化具体产品对象，并将其返回给客户端。
4. 客户端通过产品接口操作具体产品对象。

**工厂方法**

工厂方法模式将工厂抽象化，并定义一个创建对象的接口。每增加新产品，只需增加该产品以及对应的具体实现工厂类，由具体工厂类决定要实例化的产品是哪个，将对象的创建与实例化延迟到子类，这样工厂的设计就符合“开闭原则”了，扩展时不必去修改原来的代码。

工厂方法模式包含以下几个主要组成部分：

1. 抽象产品（Abstract Product）：具体产品继承的父类或实现的接口，在 Java 中一般由抽象类或者接口来实现。
2. 具体产品（Concrete Product）：实现了产品接口的具体对象，是工厂所创建的对象的具体类型。
3. 具体工厂（Factory）：被应用程序调用以创建具体产品的对象，含有和具体业务逻辑有关的代码。
4. 抽象工厂（AbstractFactory）：工厂方法模式的核心，是具体工厂角色必须实现的接口或者必须继承的父类，在 Java 中它由抽象类或者接口来实现。

**抽象工厂**

抽象工厂模式主要**用于创建相关对象的家族**。当一个产品族中需要被设计在一起工作时，通过抽象工厂模式，能够保证客户端始终只使用同一个产品族中的对象。

抽象工厂模式包含以下几个主要组成部分：

1. 抽象产品（Abstract Product）：具体产品继承的父类或实现的接口，在 Java 中一般由抽象类或者接口来实现。
2. 具体产品（Concrete Product）：实现了产品接口的具体对象，是工厂所创建的对象的具体类型。
3. 具体工厂（Factory）：用于生产不同产品族，要创建一个产品，用户只需使用其中一个工厂进行获取，完全不需要实例化任何产品对象。
4. 抽象工厂（AbstractFactory）：定义了一个接口，这个接口包含了一组方法用来生产产品，所有的具体工厂都必须实现此接口。

### 单例模式



## 用到的比较难的点？

设计模式，反射，自定义注解，枚举类

## ConcurrentHashMap与HashMap和HashTable的区别？

**基本概念不同：**

ConcurrentHashMap是一个**支持高并发更新与查询**的哈希表，**是HashTable的替代品**；

HashMap是基于哈希表的**Map接口的实现**，**允许使用null值和null键**，是线程不安全的；

HashTable和HashMap的实现原理几乎一样，但是不允许key和value为null，是线程安全的；

**底层数据结构不同**：

**HashMap**的底层数据结构主要是：**数组+链表+红黑树**，确切地说是由链表为元素的数组；

**ConcurrentHashMap**的底层数据结构是：**Segments数组**+**HashEntry数组**+**链表**；

**HashTable**的底层数据结构是：**数组+链表**；

**实现线程安全的方式不同**：

ConcurrentHashMap采用分段锁实现线程安全，容器中有多把锁，每一把锁锁一段数据，这样在多线程访问时不同段的数据时，就不会存在锁竞争了，这样便可以有效地提高并发效率；

Hashtable采用synchronized来实现线程安全，在方法上加synchronized同步锁。