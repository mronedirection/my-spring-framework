# 一、IOC相关问题

## **如何实现自研框架的IOC?**

具体实现流程为：

1. 创建注解标记需要被容器管理的类：

   创建与IOC相关的注解Component、Controller、Service以及Repository，用于标记需要被BeanContainer管理的类； 

2. 创建管理Bean的容器类BeanContainer：

   提取指定范围内的所有被注解标记的类并加载进容器中，可用ConcurrentHashMap进行保存，键代表Class对象，值代表对应的实例； 

​       BeanContainer容器的操作方式，主要涉及到容器的增删改查操作；

3. 依赖注入：

​	   由于实例里面某些必须的成员变量还没有被创建出来，因此还需进行依赖注入； 

​		定义依赖注入相关的注解标签Autowired，被此标签标记的成员变量在Spring初始化时，需要被容器创建对应		的实例，并将其注入到成员变量里；

依赖注入的具体实现逻辑为：

- 定义相关的注解标签@Autowired
- 从BeanContainer中获取被@Autowired注解标记的成员变量的实例，并通过反射将其注入到成员变量里

至此，就实现了IOC容器的创建以及依赖注入；

## 为什么要使用IOC？

## 什么是循环依赖？

A对象在创建的过程中，需要依赖注入B对象，但是B对象还未被创建，于是需要先去创建B对象，但是在创建B对象的过程中又需要注入A对象，AB互相等待对方先创建完成，这样就构成了一个死循环，AB相互依赖的关系被称为**循环依赖**。

## 如何解决循环依赖问题？

***\*Spring使用三级缓存来解决循环依赖的问题\****

singletonObjects （一级缓存）：缓存创建完成的单例Bean

earlySingletonObjects（二级缓存）：缓存不完整的Bean实例

singletonFactories（三级缓存）： 缓存创建Bean的原始工厂

三级缓存解决A和B循环依赖的问题：

1. 实例化 A，此时 A 还未完成依赖注入，只是一个半成品，为 A 创建一个 Bean工厂，将其放入三级缓存中
2. 发现 A 需要注入 B 对象，但是一级、二级、三级缓存均未发现对象 B
3. 实例化 B，此时 B 也只是一个半成品，为 B 创建一个 Bean工厂，并放入到 三级缓存中
4. 由于B 需要注入 A 对象，因此可以从三级缓存中得到对象 A，并将对象 A 放入二级缓存中，同时删除三级缓存中的对象 A
5. 对象 B 完成属性填充，执行初始化方法，并放入到一级缓存中，同时删除三级缓存中的对象 B
6. 对象 A 从一级缓存中得到对象B，完成属性填充，并放入到一级缓存中，同时删除二级缓存中的对象 A

## 为什么需要三级缓存？

如果仅仅是解决循环依赖问题，使用二级缓存就可以了，但是如果对象实现了AOP，那么注入到其他bean的时候，并不是最终的代理对象，而是原始的，这样就会产生错误。这时就需要通过三级缓存的ObjectFactory才能提前产生最终的需要代理的对象。

## **spring能解决那些循环依赖、不能解决那些循环依赖，为什么？**

***\*Spring能够解决的循环依赖情况\****：

1. 通过setter方法进行依赖注入且是在单例模式下产生的循环依赖问题：

   可以通过三级缓存解决；

**Spring不能解决的循环依赖情况：**

1. 通过构造方法进行依赖注入时产生的循环依赖问题：

   在new对象的时候就被堵塞住了，无法创建实例；

   解决办法：可以在A或者B的构造函数的形参上加个@Lazy注解实现延迟加载。@Lazy实现原理是，当实例化对象时，如果发现参数或者属性有@Lazy注解修饰，那么就不直接创建所依赖的对象了，而是使用动态代理创建一个代理类。

2. 通过setter方法进行依赖注入且是在多例（原型）模式下产生的循环依赖问题：

   每一次getBean()时，都会产生一个新的Bean，如此反复下去就会有无穷无尽的Bean产生了，最终导致StackOverflowError；
   

# 二、AOP相关问题

## **如何实现自研框架的AOP?**

项目中使用Cglib动态代理实现SpringAOP，优点是不要求被代理类实现接口，能实现代理类的无侵入

具体实现流程为：

1. 创建注解标记需要被容器管理的切面类：

   创建与AOP相关的注解Aspect和Order，用于标记切面类，以及切面类的执行顺序；

2. 定义供外部切面类使用的横切逻辑骨架：

   骨架中包含before, afterReturning以及afterThrowing等待实现的方法；

3. 实现横切逻辑以及被代理对象方法的定序执行：

   由于使用Cglib动态代理生成动态代理对象，因此需要创建 MethodInterceptor 的实现类 AspectListExecutor，在该类中按照 Order 对 Aspect 标记的切面类进行排序，实现横切逻辑以及被代理对象方法的定序执行；

4. 织入横切逻辑生成动态代理对象：

   将横切逻辑织入到被代理对象以生成动态代理对象，替换容器中的原始对象；

5. 引入AspectJ的切面表达式和相关的定位解析机制：

   在织入切面逻辑时，为了实现更加细粒度的控制，引入AspectJ框架中的pointcut表达式让切面逻辑的织入更加灵活；

使用Cglib动态代理实现的AOP1.0的不足地方：

- Aspect 标记的横切类只支持对某个标签标记的类进行横切逻辑的织入
- 需要披上 AspectJ 的外衣

**引入AspectJ的AOP 2.0：**

- 引入 AspectJ的切面表达式和相关的定位解析机制，使用pointcut 可以让切面逻辑的织入更加灵活；

## 为什么要使用AOP？

AOP可以拦截指定的方法并对方法增强，而且无需侵入到业务代码中，主要作用是分离功能性需求和非功能性需求，使开发人员可以集中处理某一个关注点或者横切逻辑，减少对业务代码的侵入，增强代码的可读性和可维护性。

简单的说，AOP 的作用就是保证开发者在不修改源代码的前提下，为系统中的业务组件添加某种通用功能。

应用场景：日志记录、事务管理、权限验证、性能监测

## JDK动态代理和Cglib(Code Generation Library) 动态代理的区别？

JDK动态代理机制是通过让动态代理类来实现和被代理类同样的接口，从而在运行中去替代被代理类来进行工作；

cglib类似子类继承，可以代理没实现接口的类，其实就是在子类中调用父类方法；

- 实现机制不同：
  - JDK动态代理基于反射机制实现，要求被代理类必须实现接口
  - Cglib基于 ASM 机制实现，通过生成被代理类的子类作为代理类，被代理类不需要实现接口

- 两者各有优势：
  - JDK动态代理的优势在于JDK原生，不需要额外引入依赖，在JVM 中运行较为可靠，平滑支持JDK版本的升级，而Cglib可能需要更新，才能在新版JDK中使用 
  - Cglib动态代理的优势在于被代理类无需实现接口，能实现代理类的无侵入

SpringAOP的底层机制是Cglib和JDK动态代理共存，如果Bean 实现了接口则用 JDK，否则使用 Cglib；

## pointcut是怎么用的，为什么使用pointcut可以让切面逻辑的织入更加灵活？

## 什么是AOP，和OOP的区别是什么？

AOP 是一种编程思想，是面向对象编程（OOP）的一种补充。

# 三、MVC相关问题

## **如何实现自研框架的MVC?**

具体实现流程为：

1. 创建实现HttpServlet的中央调度器DispatcherServlet拦截所有请求，在init方法中对容器进行初始化，以及初始化请求处理器责任链，以责任链的模式执行注册的请求处理器；在service方法中顺序执行请求处理器责任链中的请求，并对处理结果进行渲染；

2. 请求处理器主要包括PreRequestProcessor进行请求预处理，StaticResourceRequestProcessor进行静态资源请求处理，JspRequestProcessor对访问jsp资源的请求进行处理，以及最关键的ControllerRequestProcessor，负责针对特定请求，解析请求里的参数及对应的值，并赋值给Controller方法的参数，选择匹配的Controller方法进行处理，同时选择合适的Render，为后续请求处理结果的渲染做准备；

3. 对结果进行渲染相关的类ResultRender，主要包括内部异常渲染器InternalErrorResultRender，资源找不到时使用的渲染器ResourceNotFoundResultRender，Json渲染器JsonResultRender，以及页面渲染器ViewResultRender，将请求处理器处理完后的结果显示到指定的视图上；

## 为什么要使用MVC架构？

# 四、Spring相关问题

## **Spring核心模块有哪些？**

1. spring-core

   包含框架基本的核心工具类，其他组件都要使用到这个包里的类；

   定义并提供资源的访问方式；

2. spring-beans 

   Spring主要面向Bean编程（BOP）；

   包含Bean的定义、解析、创建；

3. spring-context 

   为Spring提供运行时环境，保存对象的状态；

   扩展了BeanFactory；

4. spring-aop 

   最小化的动态代理实现；

   JDK动态代理；

   Cglib；

   只能使用运行时织入，仅支持方法级编织，仅支持方法执行切入点；

## Spring中，有几种织入切面逻辑的方式？

# 五、项目中的其它问题

## 用到的设计模式？

### **门面/外观模式(Facade)**

提供一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用。

外观（Facade）模式包含以下主要角色：

- 外观（Facade）角色：为多个子系统对外提供一个共同的接口。
- 子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。

### 工厂模式

工厂模式将创建对象的**具体过程屏蔽隔离**起来，从而达到更高的灵活性，工厂模式可以分为三类：

**简单工厂**

简单工厂模式包含以下几个主要组成部分：

1. 产品接口（Product Interface）：定义了工厂所创建的对象的共同接口。该接口可以是一个抽象类或者接口，定义了产品对象的行为。
2. 具体产品（Concrete Product）：实现了产品接口的具体对象，是工厂所创建的对象的具体类型。
3. 简单工厂（Simple Factory）：负责创建产品对象的工厂类。它根据客户端的请求，决定实例化哪个具体产品对象，并将其返回给客户端。

简单工厂模式的工作流程如下：

1. 客户端通过调用工厂类的方法来请求一个产品对象。
2. 工厂类根据客户端的请求，决定实例化哪个具体产品对象。
3. 工厂类实例化具体产品对象，并将其返回给客户端。
4. 客户端通过产品接口操作具体产品对象。

**工厂方法**

工厂方法模式将工厂抽象化，并定义一个创建对象的接口。每增加新产品，只需增加该产品以及对应的具体实现工厂类，由具体工厂类决定要实例化的产品是哪个，将对象的创建与实例化延迟到子类，这样工厂的设计就符合“开闭原则”了，扩展时不必去修改原来的代码。

工厂方法模式包含以下几个主要组成部分：

1. 抽象产品（Abstract Product）：具体产品继承的父类或实现的接口，在 Java 中一般由抽象类或者接口来实现。
2. 具体产品（Concrete Product）：实现了产品接口的具体对象，是工厂所创建的对象的具体类型。
3. 具体工厂（Factory）：被应用程序调用以创建具体产品的对象，含有和具体业务逻辑有关的代码。
4. 抽象工厂（AbstractFactory）：工厂方法模式的核心，是具体工厂角色必须实现的接口或者必须继承的父类，在 Java 中它由抽象类或者接口来实现。

**抽象工厂**

抽象工厂模式主要**用于创建相关对象的家族**。当一个产品族中需要被设计在一起工作时，通过抽象工厂模式，能够保证客户端始终只使用同一个产品族中的对象。

抽象工厂模式包含以下几个主要组成部分：

1. 抽象产品（Abstract Product）：具体产品继承的父类或实现的接口，在 Java 中一般由抽象类或者接口来实现。
2. 具体产品（Concrete Product）：实现了产品接口的具体对象，是工厂所创建的对象的具体类型。
3. 具体工厂（Factory）：用于生产不同产品族，要创建一个产品，用户只需使用其中一个工厂进行获取，完全不需要实例化任何产品对象。
4. 抽象工厂（AbstractFactory）：定义了一个接口，这个接口包含了一组方法用来生产产品，所有的具体工厂都必须实现此接口。

### 代理模式

代理模式最主要的就是有一个公共接口（ToCPayment），一个具体的被代理类（ToCPaymentImpl）以及一个代理类（AlipayToC），代理类持有被代理类的实例，代为执行被代理类实例的方法。用于在真实的实现前后添加一部分通用逻辑。

应用：SpringAOP使用的就是代理模式

#### 静态代理模式：

**在编译时就已经将接口、被代理类、代理类等确定下来**。在程序运行之前，代理类的.class文件就已经生成。

静态代理的局限性：针对不同接口中同样的连接点，植入相同的逻辑，需要单独实现不同的代理类，维护成本会呈指数级增长；

#### 动态代理模式：

动态代理并没有实际的 class 文件，而是在**程序运行时生成类的字节码文件**并加载到 JVM 中

##### JDK动态代理：

JDK动态代理机制是通过**让动态代理类来实现和被代理类同样的接口，从而在运行中去替代被代理类来进行工作**；要求**【被代理的类】必须实现接口**，但是并不要求代理类【代理对象】去实现接口，所以可以复用代理对象的逻辑；

##### CGLIB动态代理：

Cglib基于 ASM 机制实现，**通过生成被代理类的子类作为代理类**，**被代理类不需要实现接口**；

SpringAOP的底层机制是Cglib和JDK动态代理共存，如果Bean 实现了接口则用 JDK，否则使用 Cglib；

### 单例模式



## 用到的比较难的点？

设计模式，反射，自定义注解，枚举类

## ConcurrentHashMap与HashMap和HashTable的区别？

**基本概念不同：**

ConcurrentHashMap是一个**支持高并发更新与查询**的哈希表，**是HashTable的替代品**；

HashMap是基于哈希表的**Map接口的实现**，**允许使用null值和null键**，是线程不安全的；

HashTable和HashMap的实现原理几乎一样，但是不允许key和value为null，是线程安全的；

**底层数据结构不同**：

**HashMap**的底层数据结构主要是：**数组+链表+红黑树**，确切地说是由链表为元素的数组；

**ConcurrentHashMap**的底层数据结构是：**Segments数组**+**HashEntry数组**+**链表**；

**HashTable**的底层数据结构是：**数组+链表**；

**实现线程安全的方式不同**：

ConcurrentHashMap采用分段锁实现线程安全，容器中有多把锁，每一把锁锁一段数据，这样在多线程访问时不同段的数据时，就不会存在锁竞争了，这样便可以有效地提高并发效率；

Hashtable采用synchronized来实现线程安全，在方法上加synchronized同步锁。